ls(net.results)
#Lets see the results
print(net.results$net.result)
#Lets display a better version of the results
cleanoutput <- cbind(testdata,sqrt(testdata),
as.data.frame(net.results$net.result))
colnames(cleanoutput) <- c("Input","Expected Output","Neural Net Output")
print(cleanoutput)
trainingdata <- cbind(traininginput,trainingoutput)
head(trainingdata)
head(traininginput)
head(trainingoutput)
head(trainingdata)
#########################################################
# Artificial Neural Network Implementation
#
# Identification of faults through supervised learning
# of an artificial neural network
#
# - Aaron Cousland 14/05/2015
########################################################
require (neuralnet)    # Nerual Network Package
require (RODBC)        # Load RODBC package
require (lubridate)    # Required to manipulate dates
# Create a connection to the database called "RTV"
odbcCloseAll()
local.connection <- odbcConnect("RTV", believeNRows=FALSE)
# Query the database and put the results into the data frame logging.results
logger.results <- sqlQuery(local.connection,"SELECT * FROM ELSPEC.RMS_TRAINING where ts between '17/Mar/15 08:00:00 AM' and '17/Mar/15 03:00:00 PM';")
odbcCloseAll()
# Order by timestamp and force local timestamp
logger.results <- logger.results[with(logger.results, order(logger.results$TS)),]
logger.results$TS <- force_tz(logger.results$TS,"AEST")
# Create Training Dataset
StartTime <- as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "AEST")
EndTime <- as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "AEST")
logger.results.training <- subset(logger.results, logger.results$TIMESTAMP >= StartTime & logger.results$TIMESTAMP <= EndTime)
# Create Validation Dataset
StartTime <- as.POSIXct("2015-03-17 08:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "AEST")
EndTime <- as.POSIXct("2015-03-17 15:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "AEST")
logger.results.validation <- subset(logger.results, logger.results$TIMESTAMP >= StartTime & logger.results$TIMESTAMP <= EndTime)
#########################################################
# Artificial Neural Network Implementation
#
# Identification of faults through supervised learning
# of an artificial neural network
#
# - Aaron Cousland 14/05/2015
########################################################
require (neuralnet)    # Nerual Network Package
require (RODBC)        # Load RODBC package
require (lubridate)    # Required to manipulate dates
# Create a connection to the database called "RTV"
odbcCloseAll()
local.connection <- odbcConnect("RTV", believeNRows=FALSE)
# Query the database and put the results into the data frame logging.results
logger.results <- sqlQuery(local.connection,"SELECT * FROM ELSPEC.RMS_TRAINING where ts between '17/Mar/15 08:00:00 AM' and '17/Mar/15 03:00:00 PM';")
odbcCloseAll()
# Order by timestamp and force local timestamp
logger.results <- logger.results[with(logger.results, order(logger.results$TS)),]
logger.results$TS <- force_tz(logger.results$TS,"UTC")
# Create Training Dataset
StartTime <- as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.training <- subset(logger.results, logger.results$TIMESTAMP >= StartTime & logger.results$TIMESTAMP <= EndTime)
# Create Validation Dataset
StartTime <- as.POSIXct("2015-03-17 08:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 15:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.validation <- subset(logger.results, logger.results$TIMESTAMP >= StartTime & logger.results$TIMESTAMP <= EndTime)
head(logger.results.training)
# Order by timestamp and force local timestamp
logger.results <- logger.results[with(logger.results, order(logger.results$TS)),]
logger.results$TS <- force_tz(logger.results$TS,"UTC")
# Create Training Dataset
StartTime <- as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.training <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
# Create Validation Dataset
StartTime <- as.POSIXct("2015-03-17 08:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 15:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.validation <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
head(logger.results.training)
fault.network <- neuralnet(FAULT~RMSI1,logger.results.training, hidden=5, threshold=0.01)
fault.network
fault.network$data
fault.network$model.list
fault.network$linear.output
write.csv (fault.network, file="test.csv")
dput(fault.network, file="Model1.nn")
print(fault.network)
print(net.sqrt)
plot(fault.network)
dput(fault.network, file=paste("Model",sys.Date(),sys.Time(),".nn")
)
dput(fault.network, file=paste("Model",Sys.Date(),Sys.Time(),".nn"))
dput(fault.network, file=paste("Model",Sys.Date(),Sys.time(),".nn"))
dput(fault.network, file=paste("Model",Sys.time(),".nn"))
save(fault.network, file="Model2.nn")
load(Model2.nn,networkmodel2)
load("Model2.nn",networkmodel2)
data("Model2.nn",networkmodel2)
load("Model2.nn",networkmodel2)
dput(fault.network, file="Model.nn"))
dput(fault.network, file="Model.nn")
dget(Model.nn)
dget("Model.nn")
save(fault.network, file="test.rda")
load("test.rda")
test <- load("test.rda")
test
load("C:/Users/acousla1/OneDrive/Projects/Fault Anticipation/Code/Signature_Detection/Artificial-Neural-Network/test.rda")
fault.network2 <- fault.network
rm(fault.network)
fault.network
load("test.rda")
fault.network
plot(fault.network)
library(clusterGeneration)
seed.val<-2
set.seed(seed.val)
num.vars<-8
num.obs<-1000
#input variables
cov.mat<-genPositiveDefMat(num.vars,covMethod=c("unifcorrmat"))$Sigma
rand.vars<-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat)
#output variables
parms<-runif(num.vars,-10,10)
y1<-rand.vars %*% matrix(parms) + rnorm(num.obs,sd=20)
parms2<-runif(num.vars,-10,10)
y2<-rand.vars %*% matrix(parms2) + rnorm(num.obs,sd=20)
#final datasets
rand.vars<-data.frame(rand.vars)
resp<-data.frame(y1,y2)
names(resp)<-c('Y1','Y2')
dat.in<-data.frame(resp,rand.vars)
library(clusterGeneration)
install.packages("clusterGeneration")
library(clusterGeneration)
seed.val<-2
set.seed(seed.val)
num.vars<-8
num.obs<-1000
#input variables
cov.mat<-genPositiveDefMat(num.vars,covMethod=c("unifcorrmat"))$Sigma
rand.vars<-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat)
#output variables
parms<-runif(num.vars,-10,10)
y1<-rand.vars %*% matrix(parms) + rnorm(num.obs,sd=20)
parms2<-runif(num.vars,-10,10)
y2<-rand.vars %*% matrix(parms2) + rnorm(num.obs,sd=20)
#final datasets
rand.vars<-data.frame(rand.vars)
resp<-data.frame(y1,y2)
names(resp)<-c('Y1','Y2')
dat.in<-data.frame(resp,rand.vars)
#nnet function from nnet package
library(nnet)
set.seed(seed.val)
mod1<-nnet(rand.vars,resp,data=dat.in,size=10,linout=T)
plot(mod1)
mod1
mod1$censored
mod1$fitted.values
mod1$wts
#Load Packages
require(quantmod) #for Lag()
require(nnet)
require(caret)
#Make toy dataset
y <- sin(seq(0, 20, 0.1))
te <- data.frame(y, x1=Lag(y), x2=Lag(y,2))
names(te) <- c("y", "x1", "x2")
#Fit model
model <- train(y ~ x1 + x2, te, method='nnet', linout=TRUE, trace = FALSE,
#Grid of tuning parameters to try:
tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1)))
ps <- predict(model, te)
#Examine results
model
plot(y)
lines(ps, col=2)
install.packages("caret")
#Load Packages
require(quantmod) #for Lag()
require(nnet)
require(caret)
install.packages("quantmod")
install.packages("quantmod")
#Load Packages
require(quantmod) #for Lag()
require(nnet)
require(caret)
#Make toy dataset
y <- sin(seq(0, 20, 0.1))
te <- data.frame(y, x1=Lag(y), x2=Lag(y,2))
names(te) <- c("y", "x1", "x2")
#Fit model
model <- train(y ~ x1 + x2, te, method='nnet', linout=TRUE, trace = FALSE,
#Grid of tuning parameters to try:
tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1)))
ps <- predict(model, te)
#Examine results
model
plot(y)
lines(ps, col=2)
te
plot(te)
head(te)
?predict
y <- sin(seq(0, 20, 0.1))
te <- data.frame(y, x1=y+runif())
te <- data.frame(y, x1=y+runif(1))
names(te) <- c("y", "x1")
plot(te$y,te$X1)
runif(1)
runif(1)
runif(1)
runif(1)
te <- data.frame(y, x1=y+runif(1)*3)
plot(te$y,te$X1)
plot(te$X1)
y <- seq(0, 20, 0.1)
te <- data.frame(y, x1=sin(y)+runif(1))
names(te) <- c("y", "x1")
plot(te$yte$X1)
plot(te$y,te$X1)
te <- data.frame(y, x1=sin(y))
plot(te$y,te$X1)
plot(te$y,te$x1)
te <- data.frame(y, x1=sin(y)+runif(1))
plot(te$y,te$x1)
te <- data.frame(y, x1=sin(y)+runif(1)*3)
plot(te$y,te$x1)
te <- data.frame(y, x1=sin(y)+(runif(1)*3))
plot(te$y,te$x1)
sin(.1)
sin(.1)+runif(1)
sin(.1)+runif(1)
sin(.1)+runif(1)
sin(.1)+runif(1)
sin(.5)+runif(1)
sin(.5)+runif(1)
sin(.5)+runif(1)
sin(.5)+runif(1)
te <- data.frame(y, x1=(sin(y)+runif(1)))
plot(te$y,te$x1)
runif(2)
runif(1)
te <- data.frame(y, x1=(sin(y)+rnorm(1)))
plot(te$y,te$x1)
x <- sin(y)+rnom(1)
x <- sin(y)+rnorm(1)
te <- data.frame(y, x1=x)
plot(te$y,te$x1)
x <- rnorm(1)
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
plot(te$y,te$x1)
set.seed(1000)
#Make toy dataset
y <- seq(0, 20, 0.1)
x <- rnorm(1)
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
plot(te$y,te$x1)
head(te)
nrow(y)
length(y)
x <- rnorm(length(y))
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
plot(te$y,te$x1)
x <- sin(y)+rnorm(length(y))
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
plot(te$y,te$x1)
x <- sin(y)+(rnorm(length(y)/10)
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
x <- sin(y)+(rnorm(length(y)/10)
)
x <- sin(y)+(rnorm(length(y))/10)
te <- data.frame(y, x1=x)
names(te) <- c("y", "x1")
plot(te$y,te$x1)
#Fit model
model <- train(y ~ x1, te, method='nnet', linout=TRUE, trace = FALSE,
#Grid of tuning parameters to try:
tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1)))
#Fit model
model <- train(y ~ x1, te, method='nnet', linout=TRUE, trace = FALSE,
#Grid of tuning parameters to try:
tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1)))
ps <- predict(model, te)
model
plot(y)
lines(ps, col=2)
plot(te$y,te$x1)
lines(ps, col=2)
plot(te$y)
lines(ps, col=2)
plot(te$y,te$x1)
lines(ps, col=2)
plot(te$y)
lines(ps, col=2)
model <- train(y ~ x1, te, method='nnet')
ps <- predict(model, te)
plot(te$y)
lines(ps, col=2)
plot(te$y,te$x1)
lines(ps, col=2)
source("http://scg.sdsu.edu/wp-content/uploads/2013/09/dataprep.r")
a = nnet(income~., data=data$train,size=20,maxit=10000,decay=.001)
table(data$val$income,predict(a,newdata=data$val,type="class"))
library(ROCR)
pred = prediction(predict(a,newdata=data$val,type="raw"),data$val$income)
perf = performance(pred,"tpr","fpr")
plot(perf,lwd=2,col="blue",main="ROC - Neural Network on Adult")
abline(a=0,b=1)
install.packages("ROCR")
library(ROCR)
pred = prediction(predict(a,newdata=data$val,type="raw"),data$val$income)
perf = performance(pred,"tpr","fpr")
plot(perf,lwd=2,col="blue",main="ROC - Neural Network on Adult")
abline(a=0,b=1)
install.packages("gplots")
library(ROCR)
pred = prediction(predict(a,newdata=data$val,type="raw"),data$val$income)
perf = performance(pred,"tpr","fpr")
plot(perf,lwd=2,col="blue",main="ROC - Neural Network on Adult")
abline(a=0,b=1)
library(gdata)
install.packages("gdata")
library(ROCR)
library(ROCR)
pred = prediction(predict(a,newdata=data$val,type="raw"),data$val$income)
perf = performance(pred,"tpr","fpr")
plot(perf,lwd=2,col="blue",main="ROC - Neural Network on Adult")
abline(a=0,b=1)
table(data$val$income,predict(a,newdata=data$val,type="class"))
source("http://scg.sdsu.edu/wp-content/uploads/2013/09/dataprep.r")
a = nnet(income~., data=data$train,size=20,maxit=1000,decay=.001)
a = nnet(income~., data=data$train,size=20,maxit=1000,decay=.001)
table(data$val$income,predict(a,newdata=data$val,type="class"))
require (RODBC)        # Load RODBC package
require (lubridate)    # Required to manipulate dates
require (nnet)
# Create a connection to the database called "RTV"
odbcCloseAll()
local.connection <- odbcConnect("RTV", believeNRows=FALSE)
# Query the database and put the results into the data frame logging.results
logger.results <- sqlQuery(local.connection,"SELECT * FROM ELSPEC.RMS_TRAINING where ts between '17/Mar/15 08:00:00 AM' and '17/Mar/15 03:00:00 PM';")
odbcCloseAll()
NeuralModel = nnet(FAULT~RMSI1, data=logger.results,size=20,maxit=100,decay=.001)
table(logger.results$FAULT,predict(NeuralModel,newdata=logger.results,type="class"))
data$val$income
head(data$val)
head(data)
table(data$val$income,predict(a,newdata=data$val,type="class"))
head(data$val$income)
data$val$income
head(data$val)
table(logger.results$FAULT,predict(NeuralModel,newdata=logger.results,type="class"))
predict<-predict(NeuralModel,logger.results,type='class')
table(logger.results$FAULT,predict(NeuralModel,newdata=logger.results))
prediction <- predict(NeuralModel,logger.results,type='class')
prediction <- predict(NeuralModel,logger.results)
head(prediction)
max(prediction)
logger.results$PrFault <- predict(NeuralModel,logger.results)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 08:45:00", format = "%Y-%m-%d %H:%M:%OS"),"AEST")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS"),"AEST")
logger.results2 <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
plot(logger.results2$TS,logger.results2$RMSI1, type="l")
polygon(logger.results2$TS,logger.results2$PrFault*max(logger.results2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Order by timestamp and force local timestamp
logger.results <- logger.results[with(logger.results, order(logger.results$TS)),]
logger.results$TS <- force_tz(logger.results$TS,"UTC")
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 08:45:00", format = "%Y-%m-%d %H:%M:%OS"),"AEST")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS"),"AEST")
logger.results2 <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
plot(logger.results2$TS,logger.results2$RMSI1, type="l")
polygon(logger.results2$TS,logger.results2$PrFault*max(logger.results2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 08:45:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results2 <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
plot(logger.results2$TS,logger.results2$RMSI1, type="l")
polygon(logger.results2$TS,logger.results2$PrFault*max(logger.results2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 09:10:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results2 <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
plot(logger.results2$TS,logger.results2$RMSI1, type="l")
polygon(logger.results2$TS,logger.results2$PrFault*max(logger.results2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
#########################################################
# Artificial Neural Network Implementation
#
# Identification of faults through supervised learning
# of an artificial neural network
#
# - Aaron Cousland 14/05/2015
########################################################
require (nnet)         # Nerual Network Package
require (RODBC)        # Load RODBC package
require (lubridate)    # Required to manipulate dates
# Create a connection to the database called "RTV"
odbcCloseAll()
local.connection <- odbcConnect("RTV", believeNRows=FALSE)
# Query the database and put the results into the data frame logging.results
logger.results <- sqlQuery(local.connection,"SELECT * FROM ELSPEC.RMS_TRAINING where ts between '17/Mar/15 08:00:00 AM' and '17/Mar/15 03:00:00 PM';")
odbcCloseAll()
# Order by timestamp and force local timestamp
logger.results <- logger.results[with(logger.results, order(logger.results$TS)),]
logger.results$TS <- force_tz(logger.results$TS,"UTC")
# Create Training Dataset
StartTime <- as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.training <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
# Create Validation Dataset
StartTime <- as.POSIXct("2015-03-17 08:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
EndTime <- as.POSIXct("2015-03-17 15:00:00", format = "%Y-%m-%d %H:%M:%OS", tz = "UTC")
logger.results.validation <- subset(logger.results, logger.results$TS >= StartTime & logger.results$TS <= EndTime)
# Generate the neural network model
NeuralModel = nnet(FAULT~RMSI1, data=logger.results.training,size=20,maxit=100,decay=.001)
#save(fault.network, file="test.rda")
#load("test.rda")
logger.results.validation$PrFault <- predict(NeuralModel,logger.results.validation)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 09:10:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 14:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 15:10:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 14:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 14:20:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Generate the neural network model
NeuralModel = nnet(FAULT~RMSI1, data=logger.results.training,size=20,maxit=1000,decay=.001)
#save(fault.network, file="test.rda")
#load("test.rda")
logger.results.validation$PrFault <- predict(NeuralModel,logger.results.validation)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 14:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 14:20:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 14:20:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 09:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 14:20:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:45:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
polygon(logger.results.validation2$TS,logger.results.validation2$FAULT*max(logger.results.validation2$RMSI1), col =rgb(0,0,1,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 11:00:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:15:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
polygon(logger.results.validation2$TS,logger.results.validation2$FAULT*max(logger.results.validation2$RMSI1), col =rgb(0,0,1,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 11:11:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 11:13:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
polygon(logger.results.validation2$TS,logger.results.validation2$FAULT*max(logger.results.validation2$RMSI1), col =rgb(0,0,1,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
# Interrogate results
StartTime <- force_tz(as.POSIXct("2015-03-17 09:11:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
EndTime <- force_tz(as.POSIXct("2015-03-17 15:13:00", format = "%Y-%m-%d %H:%M:%OS"),"UTC")
logger.results.validation2 <- subset(logger.results.validation, logger.results.validation$TS >= StartTime & logger.results.validation$TS <= EndTime)
plot(logger.results.validation2$TS,logger.results.validation2$RMSI1, type="l")
polygon(logger.results.validation2$TS,logger.results.validation2$PrFault*max(logger.results.validation2$RMSI1), col =rgb(1,0,0,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
polygon(logger.results.validation2$TS,logger.results.validation2$FAULT*max(logger.results.validation2$RMSI1), col =rgb(0,0,1,alpha=0.3),xlab="",ylab="",yaxt="n",border = NA)
axis(4)
plot(NeuralModel)
plot(NeuralModel)
